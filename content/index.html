{% extends "root.django" %}
{# :mode=django: #}

{%hyde  
 title: 'Head JS :: The only script in your HEAD'
 description:  HEAD section is absolutely the worst place to load and execute scripts. The more and the bigger the worse it gets. Stop that. Head JS is all you need.
 keywords: labjs, modernizr, parallel script loading, javascript loader, non-blocking javascript, javascript modernizer
%}

{% block hero %}

<nav>
	<a href="#highlights">highlights</a>
	<a href="#theory">theory</a>
	<a href="#usage">usage</a>
	<a href="#api">api</a>
	<a href="#download">download</a>
</nav>

<div id="hero">
   <h1>HEAD<em>JS</em></h1>
   
   <h2>The only script in your &lt;HEAD&gt;</h2>
   
   <h3>A 2.30 kb script that speeds up, simplifies and modernizes your site</h3>

	<p>
		Load scripts like images. Use HTML5 and CSS3 safely. Target CSS for different screens, paths, states and browsers. Make it the only script in your HEAD. A concise solution to universal issues.  <a href="#theory">more theory &raquo;</a>
	</p>
   
</div>

{% endblock %}

{% block content %}
# Highlights

<section id="highlights">
## JavaScript loader

Load scripts in parallel but execute in order

{% syntax js %}
head.js("/path/to/jquery.js", "/google/analytics.js", "/js/site.js", function() {
   
   // all done
   
});
{% endsyntax %}

Head JS loads scripts in parallel *without blocking* the page. The page will load faster even with a single combined file.

## JavaScript organizer

You've read the books and placed SCRIPT SRC tags on the bottom. Good. But can you do this?

{% syntax js %}
// use jQuery on the body of the page even though it is not included yet
head.ready(function() {
   $("#my").jquery_plugin();
});

// load jQuery on bottom of the page
head.js("/path/to/jquery.js");  
{% endsyntax %}

A typical problem in templating systems or in pages with separate header/footer files. 

## CSS modernizer

HeadJS adds classes to the HTML root element so that you can do this

{% syntax css %}
/* target CSS for browsers without box-shadow support */
.no-boxshadow .box {
   border: 2px solid #ddd;
}
{% endsyntax %}

The focus is on *CSS3 styling* and it's easy to add more tests. Minimalism is a must. It's your HEAD again. 
 

## HTML5 enabler

DIV is good but HeadJS let's you be semantic and futuristic

{% syntax html %}
<style>
   article { text-shadow:0 0 1px #ccc; }
</style>

<!-- works in IE too -->
<article>
   <header></header>
   <section></section>
   <footer></footer>
</article>
{% endsyntax %}

## Screen size detector 

Design pages for __1980px__ wide screen and make it also work on __10"__ laptops and mobile phones. 
Viewport size is the single most important thing when developing mobile sites.

{% syntax css %}
/* screen size less than 1024 pixels */
.lt-1024 #hero { background-image:(medium.jpg); }

/* fine tune for mobile phone */
.lt-640 #hero { background-image:(small.jpg); }
{% endsyntax %}

If you resize the browser window your CSS rules will dynamically follow. Head JS does it behind the scenes.
   
   
## Dynamic CSS
   
Style for various application states
   
{% syntax html %}
<script>
/* detect whether user is logged in. here we check for an existence of a cookie */
head.feature("logged", mycookielib.get_cookie("auth_token"));
</script>

<style>
/* .. and write CSS accordingly */
.logged #login-box { display: none; }
</style>
{% endsyntax %}

<p>
	Whenever you call `head.feature()` your CSS rules will follow. 
</p>	

   
## CSS router

Target CSS for specific paths and pages

{% syntax css %}
/* CSS targeted for home page only */
.root-section #index-page
   
/* make sidebar visible under /plugins  */   
.plugins-section #sidebar { display: block; }
{% endsyntax %}   
   

## Browser detector
   
All browsers and versions are detected but this is mostly for making IE behave well
   
{% syntax css %}
/* older than IE9 */
.lt-ie9 .box { padding: 10px; }

/* CSS fixes for IE6 */
.ie6 ul  { list-style: none; }
{% endsyntax %}

It's generally wiser to use feature detection but we all know IE: it's a feature in itself.
   
## JavaScript feature detection

Every feature can also be found on the `head` (default) JavaScript variable.
   
{% syntax js %}
if (head.logged) {
   // do things
}
{% endsyntax %}
</section>


# Theory

<section id="theory">
## Head JS script loader

With Head JS your scripts load like images - completely separated from the page rendering. The page is ready sooner. 
Always. This is guaranteed even with a single combined JavaScript file. See it yourself:

[Sample page with 5 SCRIPT SRC tags](test/script.html)

[Same scripts loaded with Head JS](test/headjs.html)

Head JS frees the page from script loading burden. The scripts are _always_ loaded in paraller no matter how
many of them and what the browser is. The difference on the user experience can be dramatic especially on the initial page load when the scripts are not yet in cache. It's your crucial first impression.

Pages no longer "hang" and there is less or zero "flashing" between pages. It's worth mentioning that a user only cares when the page is ready and current networking tools doesn't highlight this event. They focus on the overall loading of page assets.

Head JS can make your pages load 100% or sometimes even 400% faster. Script loading can make the largest impact
on client side optimization. 
	
	
## SCRIPT SRC

Regular SCRIPT SRC tags _block_ the page. The page needs to wait for all scripts to be loaded until it is rendered. This is how majority of web pages work. For example here is source code from apple.com front page.

There is not a large difference whether the script tags are placed on top or on bottom of the page. On both 
cases the scripts must be loaded before page is rendered. [Compare it yourself](test/script.html).

If you are using an older generation browser the scripts will be loaded sequentially. This will be is awfully slow. Here is a screenshot of such a scenario in Firefox 3.0. 

![sequential downloading of scripts](media/img/serial-load.gif)

It's easy to understand that this is poison for performance. The single best optimization technique for script loading is to use a non-blocking and paraller script loader such as Head JS.
	
## Developing with Head JS
		
With Head JS your page can be ready _sooner_ than your scripts. This leads to following

- The "DOM ready" event such as $(document).ready() is already fired when the scripts arrive. 
  If the loaded scripts depend on that event make sure your library can handle this. jQuery 1.4+ works.  
  
- If your scripts modify the page you can see a "flash of unbehaviored content" effect (FUBC):
  a quick glimpse of unmodified HTML before the loaded scripts act on it. You can avoid this by initially hiding 
  the modifiable elements before your scripts make them visible and do their job. 
	 
	  
## Combining scripts

There is a common misbelief that a single combined script performs best. Wrong: 

- latest browsers and Head JS can load scripts in parallel. loading 3 small files in parallel 
  instead of as a single chunk is actually faster. 

- if an individual file is changed the whole combination changes and you loose the benefits of caching. 
  it's better to combine only the stable files that doesn't change often.
  
- many popular libraries are hosted on CDN. you should take the advantage of it instead of hosting yourself 	
	
- combined files are easily larger than **15kb**. iPhone cannot cache files larger than that.

Combining scripts is a good pattern but when loading with Head JS the file amount is not _as_ critical as it is with SCRIPT SRC because page rendering is not blocked.
	
## Page styling and CSS

HEAD is the only place where a script can safely affect on page styling because it's executed before stylesheets. 
Head JS takes this important role seriously:

- you can use the latest CSS3 techniques and provide alternate CSS for IE and other old school browsers
- you can safely use HTML5 tags even with IE
- you can target CSS for specific screen widths, browsers and paths
- you can style your pages differently depending on the application state, such as whether user is logged or not

The included file must be as small as possible since it blocks the page rendering process. This was one of the primary goals when designing Head JS. It currently weights only 2.3 kb when minified and gzipped. Obviously it's preferred to load the file from a CDN. Google: I'm [staring at You](http://code.google.com/p/google-ajax-apis/issues/detail?id=548)! (like it? give it a star)

If you attempt to style the page on the scripts loaded with Head JS you can see a "Flash of Unstyled Content" effect (FOUC): the page is first rendered without the style definitions and then re-rendered when the scripts are loaded.

Note: As crazy as it sounds FUBC and FOUC are not my acronyms.
	
</section>

# Usage

<section id="usage">
## Script loading and execution

All script loading is done with `head.js()` 

{% syntax js %}
// the most simple case. load and execute single script without blocking. 
head.js("/path/to/file.js");

// load a script and execute a function after it has been loaded
head.js("/path/to/file.js", function() {
   
});

// load files in parallel but execute them in sequence
head.js("file1.js", "file2.js", ... "fileN.js");

// execute function after all scripts have been loaded
head.js("file1.js", "file2.js", function() {
   
});

// files are loaded in parallel and executed in order they arrive
head.js("file1.js");
head.js("file2.js");
head.js("file3.js");

// the previous can also be written as 
head.js("file1.js").js("file1.js").("file3.js");
{% endsyntax %}

## Script organization

Call a function after all scripts have been loaded 

{% syntax js %}
head.ready(function() {
   
});
{% endsyntax %}

The functions supplied this way are executed in the same order as they are given.

{% syntax js %}
// call a function after a particular file has been loaded
head.ready("file2.js", function() {
   
});
{% endsyntax %}

This makes sense if you have large script files and want to execute JavaScript before all files are loaded.
Otherwise you simply use `head.ready()` which gets executed after all files are loaded.

{% syntax js %}
// a handy shortcut for head.ready()
head(function() {
   
})
{% endsyntax %}

## Labeling scripts

By assigning labels the content developers need not to know the actual file paths.

{% syntax js %}
// call a function immediately after jQuery Tools is loaded
head.ready("tools", function() {
   
   // setup Tooltips
   $(".tip").tooltip();
   
});

// load scripts by assigning a label for them
head.js(
   {jquery: "http://http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"},
   {tools:  "http://cnd.jquerytools.org/1.2.5/tiny/jquery.tools.min"},
   {heavy:   "http://a.heavy.library/we/dont/want/to/wait/for.js"},

   // label is not required for all files	
   "http://can.be.mixed/with/unlabeled/files.js"
);
{% endsyntax %}

{% comment %}
On complex applications you can nest the calls for total loading control

{% syntax js %}
head.js("file1.js", function() {
   
   // load and execute these after file1 has been loaded
   head.js("file2.js");
   head.js("file3.js");
   
});
{% endsyntax %}
{% endcomment %}

## CSS3 feature detection

When a particular feature is supported a corresponding class name is added to the <html> element. 
When a feature is not supported the class name is prefixed with <code>no-</code>. For example:

{% syntax css %}
.borderimage .box {
   /* style for browsers that support border images */
}

.no-borderimage .box {
   /* style for browsers that does not support border images */
}
{% endsyntax %}

On everyday CSS work you assume that a feature exists and code your CSS accordingly and you later add
support for older browsers with the aid of "no-" classes.

### CSS3 property list

Natively detected CSS3 properties

- [borderimage](http://www.css3.info/preview/border-image/) define an image to be used instead of the normal border of an element
- [borderradius](http://www.css3.info/preview/border-radius/) support for rounded borders
- [boxshadow](http://www.css3.info/preview/box-shadow/) a simple shadow for a box
- [multiplebgs](http://www.css3.info/preview/multiple-backgrounds/) ability to define multiple background properties for a box
- [opacity](http://www.css3.info/preview/opacity/) transparency support
- [reflections](http://webkit.org/blog/182/css-reflections/) a reflection effect for an object
- [rgba](http://www.css3.info/preview/rgba/) allows to specify an opacity value for a color
- [textshadow](http://www.css3.info/preview/text-shadow/) a simple shadow for a text
- [transforms](rotate or skew boxes) ability to scale
- [transitions](https://developer.mozilla.org/en/CSS/CSS_transitions) ability to animate changes to CSS properties

You can detect more with `head.feature()` call. Here we detect HTML5 video support

{% syntax js %}
head.feature("video", function() {
	var tag = document.createElement('video');
	return !!tag.canPlayType;	
});
{% endsyntax %}

[Modernizr](https://github.com/Modernizr/Modernizr/blob/master/modernizr.js) is a good source of tests. It's preferred to append the tests inside `head.min.js` file.

## Screen size detection

Target CSS for various screen sizes. For example

{% syntax css %}
/* styling for screens with resolution less than 1024 pixels */
.lt-1024 #hero { background-image:(medium.jpg); }

/* styling for small mobile screens */
.lt-640 #hero { background-image:(small.jpg); }
{% endsyntax %}

Today most sites are optimized for **1024px** but with Head JS you can safely optimize for larger screens.
Start by designing to the largest screen and then add CSS rules for smaller ones. You can freely
decide the sizes you optimize for and the amount of them. By default Head JS watches following screen widths:

**320, 480, 640, 768, 800, 1024, 1280, 1440, 1680, 1920**

These are typical sizes for mobile phones, tablets and PC monitors. Here are sizes for Apple devices:

iPhone3: **480 x 320**

iPhone4: **960 x 640**

iPad:  **1024 x 768**

screens: **800+**

You can provide your own set of screen widths with head_conf variable:

{% syntax js %}
var head_conf = { screens: [500, 700, 900] };
{% endsyntax %}

If you resize the browser window your CSS rules will be dynamically applied. 

## Browser detection <a name="browser"></a>

Target CSS for a specific browser. For example

{% syntax css %}
/* CSS for IE version 7 and below */
.lt-ie8 .box { padding: 10px; }

/* CSS for IE6 only */
.ie6 ul  { list-style: none; }
{% endsyntax %}

List of supported class names for various browsers

- `ie` Internet Explorer
- `webkit` Webkit based browsers such as Safari and Chrome
- `opera` Opera
- `mozilla` Mozilla based browsers such as Firefox

There are additional "less than" helper classes for IE. 

{% syntax css %}
// tweak CSS for IE versions 5 and below
.ie-lt6 li {
   list-style-type: circle;
} 
{% endsyntax %}

Versions 3 - 10 are covered. It is best to avoid browser detection if you are able to do feature detection. Sometimes it's not possible especially when it comes to IE. 

## CSS Routing <a name="routing"></a>

Say you are on a page: `http://mydomain.com/addons/node/router.html`. Following CSS selectors apply:

{% syntax css %}
.addons-node-section { }

#router-page { }
{% endsyntax %}

For each given path you get a CSS class representing the "folder" and an ID representing the page. 
An empty page is "#index-page" and the site root is ".root-section". If you have an existing id assigned for the HTML element it will be *overwritten*. On this case you can place the id attribute for the BODY tag.

You can change the these suffixes with head_conf variable.

{% syntax js %}
var head_conf = { section: '-area', page: ''};
{% endsyntax %}

Now the selectors are:

{% syntax css %}
.addons-node-area { }

#router { }
{% endsyntax %}


## JavaScript feature detection <a name="global-var"></a>

Every feature can be found from th <code>head</code> global JavaScript variable. Here is a screenshot:

![Head JS global JavaScript variable](media/img/global-var.gif)

</section>

# API

<section id="api">
## Method index

### head.js(file1 ... fileN, [callback])

Immediately loads given javascript files and and executes them in the *order* they are supplied. if the last argument is a function it is called after all files are loaded and executed. Each file is either a string representing relative or absolute path of a JavaScript file. 

Alternatively each file can be given as an object taking a form: `{ label: file_path }`. The labels are a handy way to hide the actual file path from the content writers. See the `ready` method below.

### head.ready(callback)

Executes the given callback after all JavaScript files have been loaded

### head.ready(path_or_label, callback) 

Execute the callback immediately after the given file or label is loaded and executed

### head(callback), head(path_or_label, callback)

A convenience shortcut for head.ready

### head.feature(name, flag) 

Enable or disable a feature. features are stored as a class name to `<html>` element and on global `head` variable. if the flag arguments evaluates to `true` a feature is enabled. Call this method in your HEAD before the stylesheets are loaded.



## Configuration

HeadJS is configured with a global `head_conf` variable *before* the script is loaded. For example:

{% syntax html %}
<script>
var head_conf = { screens: [640, 1024, 1280, 1680] };
</script>

<script src="/js/head.min.js"></script>
{% endsyntax %}

List of configuration variables

- `head`	ability to change global variable name. default: "head". Set to "JS" and you can `JS.ready()` for example 
- `screens` an array of screen sizes to watch for  
- `section` a suffix for CSS class representing the current "folder". default: "-section"
- `page`   	a suffix for CSS ID representing the current page. default: "-page"

</section>

# Download

<section id="download">

### Development version (0.1.0 - early beta)

The library is not production ready yet. Watch Head JS on [Github](https://github.com/headjs/headjs/) to hear about the first release.

- [head.js](https://github.com/headjs/headjs/raw/master/head.js)
- [head.min.js](https://github.com/headjs/headjs/raw/master/head.min.js)
- [head.loader.js](https://github.com/headjs/headjs/raw/master/src/head.loader.js)


</section>
{% endblock %}

http://thechangelog.com/post/2058578126/headjs-the-only-script-in-your
http://code.google.com/p/extsrcjs/


